/*
================================================================
RayCaster Engine
Paul Passeron 2022
RC_MAIN.cpp
================================================================
*/


#include <SFML/Window/Keyboard.hpp>
#include <SFML/Graphics.hpp>
#include <SFML/Graphics/Image.hpp>

#include <iostream>
#include <chrono>

#include "RC_MATH.hpp"
#include "RC_GEOM.hpp"
#include "RC_GAME.hpp"

const char* TITLE = "Raycaster Engine"; //Window title
const int WIDTH = 1920; //Window width
const int HEIGHT = 1080; //Window height
const float PI = 3.141592653589793f; //The constant pi, used extensively in calculations.
geom::player pPlayer; // The player variable, used during the whole gameloop.
float fov = PI / 3.0; // The player's field of view, could become one of the player's struct field.
const float fSpeed = 10.0f; // The speed at which the player moves (nothing fancy, no sliding / friction).
const float fOmega = PI / 2; // The speed at which the player can turn.


//****************
// TEMPORARY:
// Wall array generated by the map creator, test-purposes only as it'll be loaded from a file in
// the future.
geom::line lWallsArray[24] = { geom::line(geom::point(7.16666666667, 30.3333333333), geom::point(17.0, 17.6666666667)),geom::line(geom::point(17.0, 17.6666666667), geom::point(29.1666666667, 23.5)),geom::line(geom::point(29.1666666667, 23.5), geom::point(41.0, 8.0)),geom::line(geom::point(41.0, 8.0), geom::point(48.1666666667, 23.1666666667)),geom::line(geom::point(48.1666666667, 23.1666666667), geom::point(59.3333333333, 18.3333333333)),geom::line(geom::point(59.3333333333, 18.3333333333), geom::point(76.5, 18.6666666667)),geom::line(geom::point(76.5, 18.6666666667), geom::point(76.5, 25.1666666667)),geom::line(geom::point(76.5, 25.1666666667), geom::point(70.3333333333, 33.8333333333)),geom::line(geom::point(70.3333333333, 33.8333333333), geom::point(72.5, 38.3333333333)),geom::line(geom::point(72.5, 38.3333333333), geom::point(84.0, 38.5)),geom::line(geom::point(84.0, 38.5), geom::point(87.8333333333, 52.3333333333)),geom::line(geom::point(87.8333333333, 52.3333333333), geom::point(87.5, 62.3333333333)),geom::line(geom::point(87.5, 62.3333333333), geom::point(80.5, 78.0)),geom::line(geom::point(80.5, 78.0), geom::point(61.3333333333, 76.0)),geom::line(geom::point(61.3333333333, 76.0), geom::point(43.0, 80.6666666667)),geom::line(geom::point(43.0, 80.6666666667), geom::point(36.6666666667, 68.8333333333)),geom::line(geom::point(36.6666666667, 68.8333333333), geom::point(21.8333333333, 73.3333333333)),geom::line(geom::point(21.8333333333, 73.3333333333), geom::point(24.1666666667, 80.8333333333)),geom::line(geom::point(24.1666666667, 80.8333333333), geom::point(18.3333333333, 86.8333333333)),geom::line(geom::point(18.3333333333, 86.8333333333), geom::point(14.6666666667, 83.8333333333)),geom::line(geom::point(14.6666666667, 83.8333333333), geom::point(14.5, 76.8333333333)),geom::line(geom::point(14.5, 76.8333333333), geom::point(20.8333333333, 68.5)),geom::line(geom::point(20.8333333333, 68.5), geom::point(27.3333333333, 46.3333333333)),geom::line(geom::point(27.3333333333, 46.3333333333), geom::point(7.16666666667, 30.3333333333))};
int n = 24;
//****************


sf::Texture texture; // Texture that will be displayed on the screen.
sf::Sprite sprite; // Sprite that will be displayed on the screen.


int main()
{
	//Declaring a test wall, will later be loaded from a file.
	//geom::line lWall = geom::line(geom::point(0, 2), geom::point(1, 2));
	//setting the player starting angle.
	pPlayer.angle = PI / 2;
	//Creating the buffer that contains every pixel that will
	//be rendered to the screen (RGBA).
	sf::Uint8* pixels = new sf::Uint8[WIDTH * HEIGHT * 4];
	//Creating the window
	sf::RenderWindow window(sf::VideoMode(WIDTH, HEIGHT), TITLE);
	//Creating the texture used to display on the screen.
	texture.create(WIDTH, HEIGHT);
	//Creating time variables used to calculate the elapsed time
	//between two frames.
	std::chrono::time_point<std::chrono::system_clock> m_tp1, m_tp2;
	m_tp1 = std::chrono::system_clock::now();
	m_tp2 = std::chrono::system_clock::now();
	float fElapsedTime;

	//Loading and setting the window's icon.
	auto icon = sf::Image{};
	icon.loadFromFile("icone.png");
	window.setIcon(icon.getSize().x, icon.getSize().y, icon.getPixelsPtr());
	
	//********************
	// TEMPORARY:
	auto text_wall = sf::Image();
	text_wall.loadFromFile("texture.png");
	//********************

	//Loop that stays open while the winodw is open, we put the gameplay code in here.
	while (window.isOpen())
	{
		//Calcultating the elapsed time between the previous frame and this one.
		m_tp2 = std::chrono::system_clock::now();
		std::chrono::duration<float> elapsedTime = m_tp2 - m_tp1;
		m_tp1 = m_tp2;
		fElapsedTime = elapsedTime.count();
		//std::cout << 1 / fElapsedTime << std::endl; //Prints the fps count to the console.
		
		//Creating an event to handle wether or not we have closed the window.
		sf::Event event;
		while (window.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				window.close();
		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape)) {
			window.close();
		}

		//Reset pixels to all black.
		memset(pixels, 0, WIDTH * HEIGHT * sizeof(sf::Color));
		//GameLoop ie drawig every walls etc on pixels buffer
		//gameloop(pPlayer, lWall, pixels, WIDTH, HEIGHT, fov);
		gameloop(pPlayer, lWallsArray, pixels, WIDTH, HEIGHT, fov, text_wall, n);
		//Draws the pixels buffer on the screen.
		drawScene(window, pixels, texture, sprite);
		// Handling input (player movement)
		handleKeyboardInput(fElapsedTime, pPlayer, fOmega, fSpeed);
	}
return 0;
}